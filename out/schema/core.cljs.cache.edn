;; Analyzed by ClojureScript 1.7.170
{:use-macros nil, :excludes #{Symbol fn defn defmethod letfn Keyword defrecord}, :name schema.core, :imports nil, :requires {str clojure.string, clojure.string clojure.string, utils schema.utils, schema.utils schema.utils}, :uses nil, :defs {->Predicate {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 312, :column 25, :end-line 312, :end-column 34, :internal-ctor true, :factory :positional, :arglists (quote ([p? pred-name]))}, :name schema.core/->Predicate, :variadic false, :file "out/schema/core.cljs", :end-column 34, :method-params ([p? pred-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 312, :end-line 312, :max-fixed-arity 2, :fn-var true, :arglists (quote ([p? pred-name]))}, ConditionalSchema {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/ConditionalSchema, :file "out/schema/core.cljs", :end-column 42, :type true, :column 25, :internal-ctor true, :line 523, :record true, :end-line 523, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, arity {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 939, :column 21, :end-line 939, :end-column 26, :private true, :arglists (quote ([input-schema]))}, :private true, :name schema.core/arity, :variadic false, :file "out/schema/core.cljs", :end-column 26, :method-params ([input-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 939, :end-line 939, :max-fixed-arity 1, :fn-var true, :arglists (quote ([input-schema]))}, map->FnSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 927, :column 25, :end-line 927, :end-column 33, :internal-ctor true, :factory :map, :arglists (quote ([G__22769]))}, :name schema.core/map->FnSchema, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([G__22769]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 927, :end-line 927, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22769]))}, ->One {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 800, :column 25, :end-line 800, :end-column 28, :internal-ctor true, :factory :positional, :arglists (quote ([schema optional? name]))}, :name schema.core/->One, :variadic false, :file "out/schema/core.cljs", :end-column 28, :method-params ([schema optional? name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 800, :end-line 800, :max-fixed-arity 3, :fn-var true, :arglists (quote ([schema optional? name]))}, named {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 466, :column 20, :end-line 466, :end-column 25, :arglists (quote ([schema name])), :doc "A value that must satisfy schema, and has a name for documentation purposes."}, :name schema.core/named, :variadic false, :file "out/schema/core.cljs", :end-column 25, :method-params ([schema name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 466, :end-line 466, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema name])), :doc "A value that must satisfy schema, and has a name for documentation purposes."}, optional-key {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 633, :column 20, :end-line 633, :end-column 32, :arglists (quote ([k])), :doc "An optional key in a map"}, :name schema.core/optional-key, :variadic false, :file "out/schema/core.cljs", :end-column 32, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 633, :end-line 633, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :doc "An optional key in a map"}, Protocol {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Protocol, :file "out/schema/core.cljs", :end-column 33, :type true, :column 25, :internal-ctor true, :line 343, :record true, :end-line 343, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->AnythingSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 244, :column 25, :end-line 244, :end-column 39, :internal-ctor true, :factory :map, :arglists (quote ([G__22489]))}, :name schema.core/map->AnythingSchema, :variadic false, :file "out/schema/core.cljs", :end-column 39, :method-params ([G__22489]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 244, :end-line 244, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22489]))}, map-explain {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 757, :column 21, :end-line 757, :end-column 32, :private true, :arglists (quote ([this]))}, :private true, :name schema.core/map-explain, :variadic false, :file "out/schema/core.cljs", :end-column 32, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 757, :end-line 757, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this]))}, Maybe {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Maybe, :file "out/schema/core.cljs", :end-column 30, :type true, :column 25, :internal-ctor true, :line 442, :record true, :end-line 442, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, MapEntry {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/MapEntry, :file "out/schema/core.cljs", :end-column 33, :type true, :column 25, :internal-ctor true, :line 663, :record true, :end-line 663, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, One {:num-fields 3, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/One, :file "out/schema/core.cljs", :end-column 28, :type true, :column 25, :internal-ctor true, :line 800, :record true, :end-line 800, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->Isa {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 274, :column 25, :end-line 274, :end-column 28, :internal-ctor true, :factory :positional, :arglists (quote ([h parent]))}, :name schema.core/->Isa, :variadic false, :file "out/schema/core.cljs", :end-column 28, :method-params ([h parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 274, :end-line 274, :max-fixed-arity 2, :fn-var true, :arglists (quote ([h parent]))}, map->ConditionalSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 523, :column 25, :end-line 523, :end-column 42, :internal-ctor true, :factory :map, :arglists (quote ([G__22600]))}, :name schema.core/map->ConditionalSchema, :variadic false, :file "out/schema/core.cljs", :end-column 42, :method-params ([G__22600]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 523, :end-line 523, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22600]))}, NamedSchema {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/NamedSchema, :file "out/schema/core.cljs", :end-column 36, :type true, :column 25, :internal-ctor true, :line 459, :record true, :end-line 459, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->MapEntry {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 663, :column 25, :end-line 663, :end-column 33, :internal-ctor true, :factory :map, :arglists (quote ([G__22659]))}, :name schema.core/map->MapEntry, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([G__22659]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 663, :end-line 663, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22659]))}, required-key? {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 627, :column 20, :end-line 627, :end-column 33, :arglists (quote ([ks]))}, :name schema.core/required-key?, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 627, :end-line 627, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ks]))}, ->Both {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 498, :column 25, :end-line 498, :end-column 29, :internal-ctor true, :factory :positional, :arglists (quote ([schemas]))}, :name schema.core/->Both, :variadic false, :file "out/schema/core.cljs", :end-column 29, :method-params ([schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 498, :end-line 498, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schemas]))}, schema-with-name {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 978, :column 20, :end-line 978, :end-column 36, :arglists (quote ([schema name])), :doc "Records name in schema's metadata."}, :name schema.core/schema-with-name, :variadic false, :file "out/schema/core.cljs", :end-column 36, :method-params ([schema name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 978, :end-line 978, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema name])), :doc "Records name in schema's metadata."}, Symbol {:name schema.core/Symbol, :file "out/schema/core.cljs", :line 412, :column 1, :end-line 412, :end-column 12, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 412, :column 6, :end-line 412, :end-column 12}, :doc "A symbol"}, Either {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Either, :file "out/schema/core.cljs", :end-column 31, :type true, :column 25, :internal-ctor true, :line 474, :record true, :end-line 474, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->One {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 800, :column 25, :end-line 800, :end-column 28, :internal-ctor true, :factory :map, :arglists (quote ([G__22717]))}, :name schema.core/map->One, :variadic false, :file "out/schema/core.cljs", :end-column 28, :method-params ([G__22717]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 800, :end-line 800, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22717]))}, fn-schema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 1096, :column 30, :end-line 1096, :end-column 39, :tag FnSchema, :arglists (quote ([f])), :doc "Produce the schema for a function defined with s/fn or s/defn."}, :name schema.core/fn-schema, :variadic false, :file "out/schema/core.cljs", :end-column 39, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1096, :ret-tag FnSchema, :end-line 1096, :max-fixed-arity 1, :tag FnSchema, :fn-var true, :arglists (quote ([f])), :doc "Produce the schema for a function defined with s/fn or s/defn."}, conditional {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 537, :column 20, :end-line 537, :end-column 31, :arglists (quote ([& preds-and-schemas])), :doc "Define a conditional schema.  Takes args like cond,\n   (conditional pred1 schema1 pred2 schema2 ...),\n   and checks the first schema where pred is true on the value.\n   Unlike cond, throws if the value does not match any condition.\n   :else may be used as a final condition in the place of (constantly true).\n   More efficient than either, since only one schema must be checked.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(preds-and-schemas)], :arglists ([& preds-and-schemas]), :arglists-meta (nil)}}, :name schema.core/conditional, :variadic true, :file "out/schema/core.cljs", :end-column 31, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(preds-and-schemas)], :arglists ([& preds-and-schemas]), :arglists-meta (nil)}, :method-params [(preds-and-schemas)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 537, :end-line 537, :max-fixed-arity 0, :fn-var true, :arglists ([& preds-and-schemas]), :doc "Define a conditional schema.  Takes args like cond,\n   (conditional pred1 schema1 pred2 schema2 ...),\n   and checks the first schema where pred is true on the value.\n   Unlike cond, throws if the value does not match any condition.\n   :else may be used as a final condition in the place of (constantly true).\n   More efficient than either, since only one schema must be checked."}, either {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 490, :column 20, :end-line 490, :end-column 26, :arglists (quote ([& schemas])), :doc "A value that must satisfy at least one schema in schemas.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(schemas)], :arglists ([& schemas]), :arglists-meta (nil)}}, :name schema.core/either, :variadic true, :file "out/schema/core.cljs", :end-column 26, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(schemas)], :arglists ([& schemas]), :arglists-meta (nil)}, :method-params [(schemas)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 490, :end-line 490, :max-fixed-arity 0, :fn-var true, :arglists ([& schemas]), :doc "A value that must satisfy at least one schema in schemas."}, explicit-schema-key {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 642, :column 20, :end-line 642, :end-column 39, :arglists (quote ([ks]))}, :name schema.core/explicit-schema-key, :variadic false, :file "out/schema/core.cljs", :end-column 39, :method-params ([ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 642, :end-line 642, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ks]))}, schema-name {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 983, :column 20, :end-line 983, :end-column 31, :arglists (quote ([schema])), :doc "Returns the name of a schema attached via schema-with-name (or defschema)."}, :name schema.core/schema-name, :variadic false, :file "out/schema/core.cljs", :end-column 31, :method-params ([schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 983, :end-line 983, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schema])), :doc "Returns the name of a schema attached via schema-with-name (or defschema)."}, Bool {:name schema.core/Bool, :file "out/schema/core.cljs", :line 396, :column 1, :end-line 396, :end-column 10, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 396, :column 6, :end-line 396, :end-column 10}, :doc "Boolean true or false"}, ->EqSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 258, :column 25, :end-line 258, :end-column 33, :internal-ctor true, :factory :positional, :arglists (quote ([v]))}, :name schema.core/->EqSchema, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 258, :end-line 258, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v]))}, enum {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 304, :column 20, :end-line 304, :end-column 24, :arglists (quote ([& vs])), :doc "A value that must be = to some element of vs.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(vs)], :arglists ([& vs]), :arglists-meta (nil)}}, :name schema.core/enum, :variadic true, :file "out/schema/core.cljs", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(vs)], :arglists ([& vs]), :arglists-meta (nil)}, :method-params [(vs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 304, :end-line 304, :max-fixed-arity 0, :fn-var true, :arglists ([& vs]), :doc "A value that must be = to some element of vs."}, one {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 802, :column 20, :end-line 802, :end-column 23, :arglists (quote ([schema name])), :doc "A single required element of a sequence (not repeated, the implicit default)"}, :name schema.core/one, :variadic false, :file "out/schema/core.cljs", :end-column 23, :method-params ([schema name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 802, :end-line 802, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema name])), :doc "A single required element of a sequence (not repeated, the implicit default)"}, find-extra-keys-schema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 708, :column 20, :end-line 708, :end-column 42, :arglists (quote ([map-schema]))}, :name schema.core/find-extra-keys-schema, :variadic false, :file "out/schema/core.cljs", :end-column 42, :method-params ([map-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 708, :end-line 708, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-schema]))}, map->Predicate {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 312, :column 25, :end-line 312, :end-column 34, :internal-ctor true, :factory :map, :arglists (quote ([G__22532]))}, :name schema.core/map->Predicate, :variadic false, :file "out/schema/core.cljs", :end-column 34, :method-params ([G__22532]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 312, :end-line 312, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22532]))}, map->RequiredKey {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 618, :column 25, :end-line 618, :end-column 36, :internal-ctor true, :factory :map, :arglists (quote ([G__22643]))}, :name schema.core/map->RequiredKey, :variadic false, :file "out/schema/core.cljs", :end-column 36, :method-params ([G__22643]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 618, :end-line 618, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22643]))}, Record {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Record, :file "out/schema/core.cljs", :end-column 31, :type true, :column 25, :internal-ctor true, :line 885, :record true, :end-line 885, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, parse-sequence-schema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 812, :column 20, :end-line 812, :end-column 41, :arglists (quote ([s]))}, :name schema.core/parse-sequence-schema, :variadic false, :file "out/schema/core.cljs", :end-column 41, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 812, :end-line 812, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, OptionalKey {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/OptionalKey, :file "out/schema/core.cljs", :end-column 36, :type true, :column 25, :internal-ctor true, :line 631, :record true, :end-line 631, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->Record {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 885, :column 25, :end-line 885, :end-column 31, :internal-ctor true, :factory :map, :arglists (quote ([G__22757]))}, :name schema.core/map->Record, :variadic false, :file "out/schema/core.cljs", :end-column 31, :method-params ([G__22757]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 885, :end-line 885, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22757]))}, EqSchema {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/EqSchema, :file "out/schema/core.cljs", :end-column 33, :type true, :column 25, :internal-ctor true, :line 258, :record true, :end-line 258, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, explain {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 122, :column 4, :end-line 122, :end-column 11, :protocol schema.core/Schema, :doc "Expand this schema to a human-readable format suitable for pprinting,\n     also expanding class schematas at the leaves.  Example:\n\n     user> (s/explain {:a s/Keyword :b [s/Int]} )\n     {:a Keyword, :b [Int]}", :arglists (quote ([this]))}, :protocol schema.core/Schema, :name schema.core/explain, :variadic false, :file "out/schema/core.cljs", :end-column 11, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 105, :end-line 122, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :doc "Expand this schema to a human-readable format suitable for pprinting,\n     also expanding class schematas at the leaves.  Example:\n\n     user> (s/explain {:a s/Keyword :b [s/Int]} )\n     {:a Keyword, :b [Int]}"}, ->RequiredKey {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 618, :column 25, :end-line 618, :end-column 36, :internal-ctor true, :factory :positional, :arglists (quote ([k]))}, :name schema.core/->RequiredKey, :variadic false, :file "out/schema/core.cljs", :end-column 36, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 618, :end-line 618, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, t_schema$core22554 {:num-fields 1, :protocols #{schema.core/Schema cljs.core/IMeta cljs.core/IWithMeta}, :name schema.core/t_schema$core22554, :file "out/schema/core.cljs", :type true, :anonymous true, :column 10, :line 419, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, subschema-walker {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 137, :column 16, :end-line 137, :end-column 32, :dynamic true}, :name schema.core/subschema-walker, :variadic false, :file "out/schema/core.cljs", :end-column 32, :method-params ([s]), :protocol-impl nil, :arglists-meta (), :column 1, :dynamic true, :line 137, :end-line 137, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "The function to call within 'walker' implementations to create walkers for subschemas.\n   Can be dynamically bound (using start-walker below) to create different walking behaviors.\n\n   For the curious, implemented using dynamic binding rather than making walker take a\n   subschema-walker as an argument because some behaviors (e.g. recursive schema walkers)\n   seem to require mind-bending things like fixed-point combinators that way, but are\n   simple this way."}, map->Protocol {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 343, :column 25, :end-line 343, :end-column 33, :internal-ctor true, :factory :map, :arglists (quote ([G__22548]))}, :name schema.core/map->Protocol, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([G__22548]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 343, :end-line 343, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22548]))}, map->Recursive {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 564, :column 25, :end-line 564, :end-column 34, :internal-ctor true, :factory :map, :arglists (quote ([G__22633]))}, :name schema.core/map->Recursive, :variadic false, :file "out/schema/core.cljs", :end-column 34, :method-params ([G__22633]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 564, :end-line 564, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22633]))}, preserve-map-type {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 715, :column 21, :end-line 715, :end-column 38, :private true, :arglists (quote ([original walker-result]))}, :private true, :name schema.core/preserve-map-type, :variadic false, :file "out/schema/core.cljs", :end-column 38, :method-params ([original walker-result]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 715, :end-line 715, :max-fixed-arity 2, :fn-var true, :arglists (quote ([original walker-result]))}, fn-validation? {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 1059, :column 20, :end-line 1059, :end-column 34, :arglists (quote ([])), :doc "Get the current global schema validation setting."}, :name schema.core/fn-validation?, :variadic false, :file "out/schema/core.cljs", :end-column 34, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1059, :end-line 1059, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Get the current global schema validation setting."}, isa {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 285, :column 20, :end-line 285, :end-column 23, :arglists (quote ([parent] [h parent])), :doc "A value that must be a child of parent.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([parent] [h parent]), :arglists ([parent] [h parent]), :arglists-meta (nil nil)}}, :name schema.core/isa, :variadic false, :file "out/schema/core.cljs", :end-column 23, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([parent] [h parent]), :arglists ([parent] [h parent]), :arglists-meta (nil nil)}, :method-params ([parent] [h parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 285, :end-line 285, :max-fixed-arity 2, :fn-var true, :arglists ([parent] [h parent]), :doc "A value that must be a child of parent."}, Num {:name schema.core/Num, :file "out/schema/core.cljs", :line 400, :column 1, :end-line 400, :end-column 9, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 400, :column 6, :end-line 400, :end-column 9}, :doc "Any number"}, eq {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 267, :column 20, :end-line 267, :end-column 22, :arglists (quote ([v])), :doc "A value that must be (= v)."}, :name schema.core/eq, :variadic false, :file "out/schema/core.cljs", :end-column 22, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 267, :end-line 267, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "A value that must be (= v)."}, validate {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 172, :column 20, :end-line 172, :end-column 28, :arglists (quote ([schema value])), :doc "Throw an exception if value does not satisfy schema; otherwise, return value."}, :name schema.core/validate, :variadic false, :file "out/schema/core.cljs", :end-column 28, :method-params ([schema value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 172, :end-line 172, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema value])), :doc "Throw an exception if value does not satisfy schema; otherwise, return value."}, pred {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 326, :column 20, :end-line 326, :end-column 24, :arglists (quote ([p?] [p? pred-name])), :doc "A value for which p? returns true (and does not throw).\n   Optional pred-name can be passed for nicer validation errors.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([p?] [p? pred-name]), :arglists ([p?] [p? pred-name]), :arglists-meta (nil nil)}}, :name schema.core/pred, :variadic false, :file "out/schema/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([p?] [p? pred-name]), :arglists ([p?] [p? pred-name]), :arglists-meta (nil nil)}, :method-params ([p?] [p? pred-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 326, :end-line 326, :max-fixed-arity 2, :fn-var true, :arglists ([p?] [p? pred-name]), :doc "A value for which p? returns true (and does not throw).\n   Optional pred-name can be passed for nicer validation errors."}, AnythingSchema {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/AnythingSchema, :file "out/schema/core.cljs", :end-column 39, :type true, :column 25, :internal-ctor true, :line 244, :record true, :end-line 244, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, Any {:name schema.core/Any, :file "out/schema/core.cljs", :line 252, :column 1, :end-line 252, :end-column 9, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 252, :column 6, :end-line 252, :end-column 9}, :doc "Any value, including nil."}, Regex {:name schema.core/Regex, :file "out/schema/core.cljs", :line 416, :column 1, :end-line 416, :end-column 11, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 416, :column 6, :end-line 416, :end-column 11}, :doc "A regular expression"}, ->EnumSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 295, :column 25, :end-line 295, :end-column 35, :internal-ctor true, :factory :positional, :arglists (quote ([vs]))}, :name schema.core/->EnumSchema, :variadic false, :file "out/schema/core.cljs", :end-column 35, :method-params ([vs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 295, :end-line 295, :max-fixed-arity 1, :fn-var true, :arglists (quote ([vs]))}, RequiredKey {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/RequiredKey, :file "out/schema/core.cljs", :end-column 36, :type true, :column 25, :internal-ctor true, :line 618, :record true, :end-line 618, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, explain-kspec {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 652, :column 21, :end-line 652, :end-column 34, :private true, :arglists (quote ([kspec]))}, :private true, :name schema.core/explain-kspec, :variadic false, :file "out/schema/core.cljs", :end-column 34, :method-params ([kspec]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 652, :end-line 652, :max-fixed-arity 1, :fn-var true, :arglists (quote ([kspec]))}, Inst {:name schema.core/Inst, :file "out/schema/core.cljs", :line 427, :column 1, :end-line 427, :end-column 10, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 427, :column 6, :end-line 427, :end-column 10}, :doc "The local representation of #inst ..."}, map->OptionalKey {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 631, :column 25, :end-line 631, :end-column 36, :internal-ctor true, :factory :map, :arglists (quote ([G__22651]))}, :name schema.core/map->OptionalKey, :variadic false, :file "out/schema/core.cljs", :end-column 36, :method-params ([G__22651]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 631, :end-line 631, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22651]))}, FnSchema {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/FnSchema, :file "out/schema/core.cljs", :end-column 33, :type true, :column 25, :internal-ctor true, :line 927, :record true, :end-line 927, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, if {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 550, :column 20, :end-line 550, :end-column 22, :arglists (quote ([pred if-schema else-schema])), :doc "if the predicate returns truthy, use the if-schema, otherwise use the else-schema"}, :name schema.core/if, :variadic false, :file "out/schema/core.cljs", :end-column 22, :method-params ([pred if-schema else-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 550, :end-line 550, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pred if-schema else-schema])), :doc "if the predicate returns truthy, use the if-schema, otherwise use the else-schema"}, Predicate {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Predicate, :file "out/schema/core.cljs", :end-column 34, :type true, :column 25, :internal-ctor true, :line 312, :record true, :end-line 312, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, make-fn-schema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 946, :column 20, :end-line 946, :end-column 34, :arglists (quote ([output-schema input-schemas])), :doc "A function outputting a value in output schema, whose argument vector must match one of\n   input-schemas, each of which should be a sequence schema.\n   Currently function schemas are purely descriptive; they validate against any function,\n   regardless of actual input and output types."}, :name schema.core/make-fn-schema, :variadic false, :file "out/schema/core.cljs", :end-column 34, :method-params ([output-schema input-schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 946, :end-line 946, :max-fixed-arity 2, :fn-var true, :arglists (quote ([output-schema input-schemas])), :doc "A function outputting a value in output schema, whose argument vector must match one of\n   input-schemas, each of which should be a sequence schema.\n   Currently function schemas are purely descriptive; they validate against any function,\n   regardless of actual input and output types."}, map-walker {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 720, :column 21, :end-line 720, :end-column 31, :private true, :arglists (quote ([map-schema]))}, :private true, :name schema.core/map-walker, :variadic false, :file "out/schema/core.cljs", :end-column 31, :method-params ([map-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 720, :end-line 720, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-schema]))}, Str {:name schema.core/Str, :file "out/schema/core.cljs", :line 391, :column 1, :end-line 391, :end-column 9, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 391, :column 6, :end-line 391, :end-column 9}, :doc "Satisfied only by String.\n   Is (pred string?) and not js/String in cljs because of keywords."}, map->EqSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 258, :column 25, :end-line 258, :end-column 33, :internal-ctor true, :factory :map, :arglists (quote ([G__22497]))}, :name schema.core/map->EqSchema, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([G__22497]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 258, :end-line 258, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22497]))}, ->AnythingSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 244, :column 25, :end-line 244, :end-column 39, :internal-ctor true, :factory :positional, :arglists (quote ([_]))}, :name schema.core/->AnythingSchema, :variadic false, :file "out/schema/core.cljs", :end-column 39, :method-params ([_]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 244, :end-line 244, :max-fixed-arity 1, :fn-var true, :arglists (quote ([_]))}, maybe {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 451, :column 20, :end-line 451, :end-column 25, :arglists (quote ([schema])), :doc "A value that must either be nil or satisfy schema"}, :name schema.core/maybe, :variadic false, :file "out/schema/core.cljs", :end-column 25, :method-params ([schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 451, :end-line 451, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schema])), :doc "A value that must either be nil or satisfy schema"}, check {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 166, :column 20, :end-line 166, :end-column 25, :arglists (quote ([schema x])), :doc "Return nil if x matches schema; otherwise, returns a value that looks like the\n   'bad' parts of x with ValidationErrors at the leaves describing the failures."}, :name schema.core/check, :variadic false, :file "out/schema/core.cljs", :end-column 25, :method-params ([schema x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 166, :end-line 166, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema x])), :doc "Return nil if x matches schema; otherwise, returns a value that looks like the\n   'bad' parts of x with ValidationErrors at the leaves describing the failures."}, pair {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 871, :column 20, :end-line 871, :end-column 24, :arglists (quote ([first-schema first-name second-schema second-name])), :doc "A schema for a pair of schemas and their names"}, :name schema.core/pair, :variadic false, :file "out/schema/core.cljs", :end-column 24, :method-params ([first-schema first-name second-schema second-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 871, :end-line 871, :max-fixed-arity 4, :fn-var true, :arglists (quote ([first-schema first-name second-schema second-name])), :doc "A schema for a pair of schemas and their names"}, set-fn-validation! {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 1064, :column 20, :end-line 1064, :end-column 38, :arglists (quote ([on?])), :doc "Globally turn on schema validation for all s/fn and s/defn instances."}, :name schema.core/set-fn-validation!, :variadic false, :file "out/schema/core.cljs", :end-column 38, :method-params ([on?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1064, :end-line 1064, :max-fixed-arity 1, :fn-var true, :arglists (quote ([on?])), :doc "Globally turn on schema validation for all s/fn and s/defn instances."}, EnumSchema {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/EnumSchema, :file "out/schema/core.cljs", :end-column 35, :type true, :column 25, :internal-ctor true, :line 295, :record true, :end-line 295, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->OptionalKey {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 631, :column 25, :end-line 631, :end-column 36, :internal-ctor true, :factory :positional, :arglists (quote ([k]))}, :name schema.core/->OptionalKey, :variadic false, :file "out/schema/core.cljs", :end-column 36, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 631, :end-line 631, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ->ConditionalSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 523, :column 25, :end-line 523, :end-column 42, :internal-ctor true, :factory :positional, :arglists (quote ([preds-and-schemas]))}, :name schema.core/->ConditionalSchema, :variadic false, :file "out/schema/core.cljs", :end-column 42, :method-params ([preds-and-schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 523, :end-line 523, :max-fixed-arity 1, :fn-var true, :arglists (quote ([preds-and-schemas]))}, ->NamedSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 459, :column 25, :end-line 459, :end-column 36, :internal-ctor true, :factory :positional, :arglists (quote ([schema name]))}, :name schema.core/->NamedSchema, :variadic false, :file "out/schema/core.cljs", :end-column 36, :method-params ([schema name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 459, :end-line 459, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema name]))}, schematize-fn {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 1091, :column 20, :end-line 1091, :end-column 33, :arglists (quote ([f schema])), :doc "Attach the schema to fn f at runtime, extractable by fn-schema."}, :name schema.core/schematize-fn, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([f schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1091, :end-line 1091, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f schema])), :doc "Attach the schema to fn f at runtime, extractable by fn-schema."}, Uuid {:name schema.core/Uuid, :file "out/schema/core.cljs", :line 431, :column 1, :end-line 431, :end-column 10, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 431, :column 6, :end-line 431, :end-column 10}, :doc "The local representation of #uuid ..."}, map->Isa {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 274, :column 25, :end-line 274, :end-column 28, :internal-ctor true, :factory :map, :arglists (quote ([G__22505]))}, :name schema.core/map->Isa, :variadic false, :file "out/schema/core.cljs", :end-column 28, :method-params ([G__22505]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 274, :end-line 274, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22505]))}, map->Either {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 474, :column 25, :end-line 474, :end-column 31, :internal-ctor true, :factory :map, :arglists (quote ([G__22575]))}, :name schema.core/map->Either, :variadic false, :file "out/schema/core.cljs", :end-column 31, :method-params ([G__22575]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 474, :end-line 474, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22575]))}, schema-ns {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 988, :column 20, :end-line 988, :end-column 29, :arglists (quote ([schema])), :doc "Returns the namespace of a schema attached via defschema."}, :name schema.core/schema-ns, :variadic false, :file "out/schema/core.cljs", :end-column 29, :method-params ([schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 988, :end-line 988, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schema])), :doc "Returns the namespace of a schema attached via defschema."}, ->Record {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 885, :column 25, :end-line 885, :end-column 31, :internal-ctor true, :factory :positional, :arglists (quote ([klass schema]))}, :name schema.core/->Record, :variadic false, :file "out/schema/core.cljs", :end-column 31, :method-params ([klass schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 885, :end-line 885, :max-fixed-arity 2, :fn-var true, :arglists (quote ([klass schema]))}, ->Recursive {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 564, :column 25, :end-line 564, :end-column 34, :internal-ctor true, :factory :positional, :arglists (quote ([derefable]))}, :name schema.core/->Recursive, :variadic false, :file "out/schema/core.cljs", :end-column 34, :method-params ([derefable]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 564, :end-line 564, :max-fixed-arity 1, :fn-var true, :arglists (quote ([derefable]))}, protocol-name {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 338, :column 20, :end-line 338, :end-column 33, :arglists (quote ([protocol]))}, :name schema.core/protocol-name, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([protocol]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 338, :end-line 338, :max-fixed-arity 1, :fn-var true, :arglists (quote ([protocol]))}, Isa {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Isa, :file "out/schema/core.cljs", :end-column 28, :type true, :column 25, :internal-ctor true, :line 274, :record true, :end-line 274, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, +missing+ {:name schema.core/+missing+, :file "out/schema/core.cljs", :line 614, :column 1, :end-line 614, :end-column 24, :no-doc true, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 614, :column 15, :end-line 614, :end-column 24, :no-doc true}, :doc "A sentinel value representing missing portions of the input data."}, ->Either {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 474, :column 25, :end-line 474, :end-column 31, :internal-ctor true, :factory :positional, :arglists (quote ([schemas]))}, :name schema.core/->Either, :variadic false, :file "out/schema/core.cljs", :end-column 31, :method-params ([schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 474, :end-line 474, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schemas]))}, map->NamedSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 459, :column 25, :end-line 459, :end-column 36, :internal-ctor true, :factory :map, :arglists (quote ([G__22567]))}, :name schema.core/map->NamedSchema, :variadic false, :file "out/schema/core.cljs", :end-column 36, :method-params ([G__22567]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 459, :end-line 459, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22567]))}, start-walker {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 151, :column 20, :end-line 151, :end-column 32, :arglists (quote ([sub-walker schema])), :doc "The entry point for creating walkers.  Binds the provided walker to subschema-walker,\n   then calls it on the provided schema.  For simple validation, pass walker as sub-walker.\n   More sophisticated behavior (coercion, etc), can be achieved by passing a sub-walker\n   that wraps walker with additional behavior."}, :name schema.core/start-walker, :variadic false, :file "out/schema/core.cljs", :end-column 32, :method-params ([sub-walker schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 151, :end-line 151, :max-fixed-arity 2, :fn-var true, :arglists (quote ([sub-walker schema])), :doc "The entry point for creating walkers.  Binds the provided walker to subschema-walker,\n   then calls it on the provided schema.  For simple validation, pass walker as sub-walker.\n   More sophisticated behavior (coercion, etc), can be achieved by passing a sub-walker\n   that wraps walker with additional behavior."}, checker {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 160, :column 20, :end-line 160, :end-column 27, :arglists (quote ([schema])), :doc "Compile an efficient checker for schema, which returns nil for valid values and\n   error descriptions otherwise."}, :name schema.core/checker, :variadic false, :file "out/schema/core.cljs", :end-column 27, :method-params ([schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 160, :end-line 160, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schema])), :doc "Compile an efficient checker for schema, which returns nil for valid values and\n   error descriptions otherwise."}, Keyword {:name schema.core/Keyword, :file "out/schema/core.cljs", :line 408, :column 1, :end-line 408, :end-column 13, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 408, :column 6, :end-line 408, :end-column 13}, :doc "A keyword"}, recursive {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 583, :column 20, :end-line 583, :end-column 29, :arglists (quote ([schema])), :doc "Support for (mutually) recursive schemas by passing a var that points to a schema,\n   e.g (recursive #'ExampleRecursiveSchema)."}, :name schema.core/recursive, :variadic false, :file "out/schema/core.cljs", :end-column 29, :method-params ([schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 583, :end-line 583, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schema])), :doc "Support for (mutually) recursive schemas by passing a var that points to a schema,\n   e.g (recursive #'ExampleRecursiveSchema)."}, Recursive {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Recursive, :file "out/schema/core.cljs", :end-column 34, :type true, :column 25, :internal-ctor true, :line 564, :record true, :end-line 564, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->MapEntry {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 663, :column 25, :end-line 663, :end-column 33, :internal-ctor true, :factory :positional, :arglists (quote ([kspec val-schema]))}, :name schema.core/->MapEntry, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([kspec val-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 663, :end-line 663, :max-fixed-arity 2, :fn-var true, :arglists (quote ([kspec val-schema]))}, ->Protocol {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 343, :column 25, :end-line 343, :end-column 33, :internal-ctor true, :factory :positional, :arglists (quote ([p]))}, :name schema.core/->Protocol, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([p]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 343, :end-line 343, :max-fixed-arity 1, :fn-var true, :arglists (quote ([p]))}, ->Maybe {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 442, :column 25, :end-line 442, :end-column 30, :internal-ctor true, :factory :positional, :arglists (quote ([schema]))}, :name schema.core/->Maybe, :variadic false, :file "out/schema/core.cljs", :end-column 30, :method-params ([schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 442, :end-line 442, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schema]))}, explain-input-schema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 921, :column 20, :end-line 921, :end-column 40, :arglists (quote ([input-schema]))}, :name schema.core/explain-input-schema, :variadic false, :file "out/schema/core.cljs", :end-column 40, :method-params ([input-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 921, :end-line 921, :max-fixed-arity 1, :fn-var true, :arglists (quote ([input-schema]))}, record {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 904, :column 20, :end-line 904, :end-column 26, :arglists (quote ([klass schema])), :doc "A Record instance of type klass, whose elements match map schema 'schema'."}, :name schema.core/record, :variadic false, :file "out/schema/core.cljs", :end-column 26, :method-params ([klass schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 904, :end-line 904, :max-fixed-arity 2, :fn-var true, :arglists (quote ([klass schema])), :doc "A Record instance of type klass, whose elements match map schema 'schema'."}, optional-key? {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 638, :column 20, :end-line 638, :end-column 33, :arglists (quote ([ks]))}, :name schema.core/optional-key?, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 638, :end-line 638, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ks]))}, map->Both {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 498, :column 25, :end-line 498, :end-column 29, :internal-ctor true, :factory :map, :arglists (quote ([G__22588]))}, :name schema.core/map->Both, :variadic false, :file "out/schema/core.cljs", :end-column 29, :method-params ([G__22588]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 498, :end-line 498, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22588]))}, required-key {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 620, :column 20, :end-line 620, :end-column 32, :arglists (quote ([k])), :doc "A required key in a map"}, :name schema.core/required-key, :variadic false, :file "out/schema/core.cljs", :end-column 32, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 620, :end-line 620, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :doc "A required key in a map"}, optional {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 807, :column 20, :end-line 807, :end-column 28, :arglists (quote ([schema name])), :doc "A single optional element of a sequence (not repeated, the implicit default)"}, :name schema.core/optional, :variadic false, :file "out/schema/core.cljs", :end-column 28, :method-params ([schema name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 807, :end-line 807, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema name])), :doc "A single optional element of a sequence (not repeated, the implicit default)"}, ->t_schema$core22554 {:protocol-inline nil, :meta {:anonymous true, :protocols #{schema.core/Schema cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta22555])), :file nil}, :protocols #{schema.core/Schema cljs.core/IMeta cljs.core/IWithMeta}, :name schema.core/->t_schema$core22554, :variadic false, :file "out/schema/core.cljs", :method-params ([meta22555]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 10, :factory :positional, :line 419, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta22555])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, Int {:name schema.core/Int, :file "out/schema/core.cljs", :line 404, :column 1, :end-line 404, :end-column 9, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 404, :column 6, :end-line 404, :end-column 9}, :doc "Any integral number"}, ->FnSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 927, :column 25, :end-line 927, :end-column 33, :internal-ctor true, :factory :positional, :arglists (quote ([output-schema input-schemas]))}, :name schema.core/->FnSchema, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([output-schema input-schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 927, :end-line 927, :max-fixed-arity 2, :fn-var true, :arglists (quote ([output-schema input-schemas]))}, Schema {:meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 105, :column 14, :end-line 105, :end-column 20, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {walker [[this]], explain [[this]]}}}, :protocol-symbol true, :name schema.core/Schema, :file "out/schema/core.cljs", :end-column 20, :column 1, :line 105, :protocol-info {:methods {walker [[this]], explain [[this]]}}, :info nil, :end-line 105, :impls #{schema.core/Isa cljs/core.PersistentHashMap js/RegExp schema.core/Recursive schema.core/t_schema$core22554 cljs/core.PersistentArrayMap schema.core/NamedSchema cljs/core.PersistentVector schema.core/Either schema.core/Both cljs/core.PersistentHashSet schema.core/ConditionalSchema schema.core/Record schema.core/EqSchema schema.core/MapEntry function schema.core/Maybe schema.core/AnythingSchema schema.core/FnSchema schema.core/Predicate schema.core/EnumSchema schema.core/Protocol}, :doc nil, :jsdoc ("@interface")}, Both {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Both, :file "out/schema/core.cljs", :end-column 29, :type true, :column 25, :internal-ctor true, :line 498, :record true, :end-line 498, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->Maybe {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 442, :column 25, :end-line 442, :end-column 30, :internal-ctor true, :factory :map, :arglists (quote ([G__22559]))}, :name schema.core/map->Maybe, :variadic false, :file "out/schema/core.cljs", :end-column 30, :method-params ([G__22559]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 442, :end-line 442, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22559]))}, map-entry {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 702, :column 20, :end-line 702, :end-column 29, :arglists (quote ([kspec val-schema]))}, :name schema.core/map-entry, :variadic false, :file "out/schema/core.cljs", :end-column 29, :method-params ([kspec val-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 702, :end-line 702, :max-fixed-arity 2, :fn-var true, :arglists (quote ([kspec val-schema]))}, walker {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 106, :column 4, :end-line 106, :end-column 10, :protocol schema.core/Schema, :doc "Produce a function that takes [data], and either returns a walked version of data\n     (by default, usually just data), or a utils/ErrorContainer containing value that looks\n     like the 'bad' parts of data with ValidationErrors at the leaves describing the failures.\n\n     If this is a composite schema, should let-bind (subschema-walker sub-schema) for each\n     subschema outside the returned fn.  Within the returned fn, should break down data\n     into constituents, call the let-bound subschema walkers on each component, and then\n     reassemble the components into a walked version of the data (or an ErrorContainer\n     describing the validaiton failures).\n\n     Attempting to walk a value that already contains a utils/ErrorContainer produces undefined\n     behavior.\n\n     User code should never call `walker` directly.  Instead, it should call `start-walker`\n     below.", :arglists (quote ([this]))}, :protocol schema.core/Schema, :name schema.core/walker, :variadic false, :file "out/schema/core.cljs", :end-column 10, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 105, :end-line 106, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :doc "Produce a function that takes [data], and either returns a walked version of data\n     (by default, usually just data), or a utils/ErrorContainer containing value that looks\n     like the 'bad' parts of data with ValidationErrors at the leaves describing the failures.\n\n     If this is a composite schema, should let-bind (subschema-walker sub-schema) for each\n     subschema outside the returned fn.  Within the returned fn, should break down data\n     into constituents, call the let-bound subschema walkers on each component, and then\n     reassemble the components into a walked version of the data (or an ErrorContainer\n     describing the validaiton failures).\n\n     Attempting to walk a value that already contains a utils/ErrorContainer produces undefined\n     behavior.\n\n     User code should never call `walker` directly.  Instead, it should call `start-walker`\n     below."}, specific-key? {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 648, :column 20, :end-line 648, :end-column 33, :arglists (quote ([ks]))}, :name schema.core/specific-key?, :variadic false, :file "out/schema/core.cljs", :end-column 33, :method-params ([ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 648, :end-line 648, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ks]))}, var-name {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 560, :column 20, :end-line 560, :end-column 28, :arglists (quote ([v]))}, :name schema.core/var-name, :variadic false, :file "out/schema/core.cljs", :end-column 28, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 560, :end-line 560, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v]))}, map->EnumSchema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 295, :column 25, :end-line 295, :end-column 35, :internal-ctor true, :factory :map, :arglists (quote ([G__22520]))}, :name schema.core/map->EnumSchema, :variadic false, :file "out/schema/core.cljs", :end-column 35, :method-params ([G__22520]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 295, :end-line 295, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__22520]))}, both {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/schema/core.cljs", :line 515, :column 20, :end-line 515, :end-column 24, :arglists (quote ([& schemas])), :doc "A value that must satisfy every schema in schemas.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(schemas)], :arglists ([& schemas]), :arglists-meta (nil)}}, :name schema.core/both, :variadic true, :file "out/schema/core.cljs", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(schemas)], :arglists ([& schemas]), :arglists-meta (nil)}, :method-params [(schemas)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 515, :end-line 515, :max-fixed-arity 0, :fn-var true, :arglists ([& schemas]), :doc "A value that must satisfy every schema in schemas."}}, :require-macros {macros schema.macros, schema.macros schema.macros, schema.core schema.core}, :cljs.analyzer/constants {:seen #{& named :schema optional-key present? satisfies? p? js/RegExp = :klass :v :schema.core/error p isa? Symbol throws? vs :parent conditional :else missing-required-key either enum sequential? one :_ set? :kspec :ns schema :name :extra-validator-fn :output-schema :value xk klass v map? :proto-sym has-extra-elts? :input-schemas string? :type eq parent :derefable pred Any Regex protocol :val-schema keyword? :schema.core/missing :preds-and-schemas _ % Str kspec :k maybe check name output-schema :optional? input-schemas some derefable :schemas instance? re-find not :h val-schema preds-and-schemas meta22555 :pred-name k integer? => Keyword recursive ifn? :error optional? var schemas =>* h :p? ... invalid-key record count pred-name required-key optional :proto-pred Int matches-some-condition? :p :vs map-entry symbol? both disallowed-key}, :order [:type :schema :value :error :schema.core/error instance? :_ Any _ :v = eq v :h :parent isa? h parent :vs enum vs :p? :pred-name throws? :else not Int Keyword Symbol Str pred p? pred-name :proto-sym :p :proto-pred satisfies? protocol p string? re-find integer? keyword? symbol? js/RegExp Regex meta22555 maybe schema :name named name :schemas schemas % check some either both :preds-and-schemas matches-some-condition? conditional preds-and-schemas :ns :derefable var ... recursive derefable :schema.core/missing :k k required-key optional-key :kspec :val-schema missing-required-key count xk invalid-key map-entry kspec val-schema map? disallowed-key set? :optional? optional? sequential? present? has-extra-elts? optional one :klass :extra-validator-fn record klass & :output-schema :input-schemas ifn? =>* => output-schema input-schemas]}, :doc "A library for data shape definition and validation. A Schema is just Clojure data,\n   which can be used to document and validate Clojure functions and data.\n\n   For example,\n\n   (def FooBar {:foo Keyword :bar [Number]}) ;; a schema\n\n   (check FooBar {:foo :k :bar [1.0 2.0 3.0]})\n   ==> nil\n\n   representing successful validation, but the following all return helpful errors\n   describing how the provided data fails to measure up to schema FooBar's standards.\n\n   (check FooBar {:bar [1.0 2.0 3.0]})\n   ==> {:foo missing-required-key}\n\n   (check FooBar {:foo 1 :bar [1.0 2.0 3.0]})\n   ==> {:foo (not (keyword? 1))}\n\n   (check FooBar {:foo :k :bar [1.0 2.0 3.0] :baz 1})\n   ==> {:baz disallowed-key}\n\n   Schema lets you describe your leaf values using the Any, Keyword, Symbol, Number,\n   String, and Int definitions below, or (in Clojure) you can use arbitrary Java\n   classes or primitive casts to describe simple values.\n\n   From there, you can build up schemas for complex types using Clojure syntax\n   (map literals for maps, set literals for sets, vector literals for sequences,\n   with details described below), plus helpers below that provide optional values,\n   enumerations, arbitrary predicates, and more.\n\n   Assuming you (:require [schema.core :as s :include-macros true]),\n   Schema also provides macros for defining records with schematized elements\n   (s/defrecord), and named or anonymous functions (s/fn and s/defn) with\n   schematized inputs and return values.  In addition to producing better-documented\n   records and functions, these macros allow you to retrieve the schema associated\n   with the defined record or function.  Moreover, functions include optional\n   *validation*, which will throw an error if the inputs or outputs do not\n   match the provided schemas:\n\n   (s/defrecord FooBar\n    [foo :- Int\n     bar :- String])\n\n   (s/defn quux :- Int\n    [foobar :- Foobar\n     mogrifier :- Number]\n    (* mogrifier (+ (:foo foobar) (Long/parseLong (:bar foobar)))))\n\n   (quux (FooBar. 10 \"5\") 2)\n   ==> 30\n\n   (fn-schema quux)\n   ==> (=> Int (record user.FooBar {:foo Int, :bar java.lang.String}) java.lang.Number)\n\n   (s/with-fn-validation (quux (FooBar. 10.2 \"5\") 2))\n   ==> Input to quux does not match schema: [(named {:foo (not (integer? 10.2))} foobar) nil]\n\n   As you can see, the preferred syntax for providing type hints to schema's defrecord,\n   fn, and defn macros is to follow each element, argument, or function name with a\n   :- schema.  Symbols without schemas default to a schema of Any.  In Clojure,\n   class (e.g., clojure.lang.String) and primitive schemas (long, double) are also\n   propagated to tag metadata to ensure you get the type hinting and primitive\n   behavior you ask for.\n\n   If you don't like this style, standard Clojure-style typehints are also supported:\n\n   (fn-schema (s/fn [^String x]))\n   ==> (=> Any java.lang.String)\n\n   You can directly type hint a symbol as a class, primitive, or simple\n   schema.\n\n   See the docstrings of defrecord, fn, and defn for more details about how\n   to use these macros."}