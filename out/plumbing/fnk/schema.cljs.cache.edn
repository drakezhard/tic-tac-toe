;; Analyzed by ClojureScript 1.7.170
{:use-macros {assert-iae plumbing.fnk.schema}, :excludes #{}, :name plumbing.fnk.schema, :imports nil, :requires {s schema.core, schema.core schema.core, schema-utils schema.utils, schema.utils schema.utils}, :uses nil, :defs {required-toplevel-keys {:schema (schema.core/make-fn-schema output-schema29275 [input-schema29276]), :protocol-inline nil, :meta {:arglists (quote ([input-schema])), :file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 141, :column 9, :end-line 141, :end-column 31, :schema (schema.core/make-fn-schema output-schema29275 [input-schema29276]), :doc "Inputs: [input-schema :- InputSchema]\n  Returns: [s/Keyword]\n\n  Which top-level keys are required (i.e., non-false) by this input schema.", :raw-arglists (quote ([input-schema :- InputSchema]))}, :name plumbing.fnk.schema/required-toplevel-keys, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 31, :method-params ([G__29279]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :raw-arglists (quote ([input-schema :- InputSchema])), :line 141, :end-line 141, :max-fixed-arity 1, :fn-var true, :arglists (quote ([input-schema])), :doc "Inputs: [input-schema :- InputSchema]\n  Returns: [s/Keyword]\n\n  Which top-level keys are required (i.e., non-false) by this input schema."}, InputSchema {:name plumbing.fnk.schema/InputSchema, :file "out/plumbing/fnk/schema.cljs", :line 23, :column 1, :end-line 23, :end-column 17, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 23, :column 6, :end-line 23, :end-column 17}}, possibly-contains? {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 217, :column 7, :end-line 217, :end-column 25, :arglists (quote ([m k]))}, :name plumbing.fnk.schema/possibly-contains?, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 25, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 217, :end-line 217, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k]))}, schema-key {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 208, :column 7, :end-line 208, :end-column 17, :arglists (quote ([m k]))}, :name plumbing.fnk.schema/schema-key, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 17, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 208, :end-line 208, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k]))}, map-schema? {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 74, :column 7, :end-line 74, :end-column 18, :arglists (quote ([m]))}, :name plumbing.fnk.schema/map-schema?, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 18, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 74, :end-line 74, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, MapOutputSchema {:name plumbing.fnk.schema/MapOutputSchema, :file "out/plumbing/fnk/schema.cljs", :line 28, :column 1, :end-line 28, :end-column 21, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 28, :column 6, :end-line 28, :end-column 21}}, unwrap-schema-form-key {:schema (schema.core/make-fn-schema output-schema29203 [input-schema29204]), :protocol-inline nil, :meta {:arglists (quote ([k])), :file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 81, :column 9, :end-line 81, :end-column 31, :schema (schema.core/make-fn-schema output-schema29203 [input-schema29204]), :doc "Inputs: [k]\n  Returns: (s/maybe (s/pair s/Keyword \"k\" s/Bool \"optional?\"))\n\n  Given a possibly-unevaluated schema map key form, unpack an explicit keyword\n   and optional? flag, or return nil for a non-explicit key", :raw-arglists (quote ([k]))}, :name plumbing.fnk.schema/unwrap-schema-form-key, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 31, :method-params ([G__29207]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :raw-arglists (quote ([k])), :line 81, :end-line 81, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :doc "Inputs: [k]\n  Returns: (s/maybe (s/pair s/Keyword \"k\" s/Bool \"optional?\"))\n\n  Given a possibly-unevaluated schema map key form, unpack an explicit keyword\n   and optional? flag, or return nil for a non-explicit key"}, non-map-union {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 62, :column 7, :end-line 62, :end-column 20, :arglists (quote ([s1 s2]))}, :name plumbing.fnk.schema/non-map-union, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 20, :method-params ([s1 s2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 62, :end-line 62, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s1 s2]))}, split-schema-keys {:schema (schema.core/make-fn-schema output-schema29233 [input-schema29234]), :protocol-inline nil, :meta {:arglists (quote ([s])), :file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 102, :column 9, :end-line 102, :end-column 26, :schema (schema.core/make-fn-schema output-schema29233 [input-schema29234]), :doc "Inputs: [s :- {s/Keyword s/Bool}]\n  Returns: [(s/one [s/Keyword] (quote required)) (s/one [s/Keyword] (quote optional))]\n\n  Given output of explicit-schema-key-map, split into seq [req opt].", :raw-arglists (quote ([s :- {s/Keyword s/Bool}]))}, :name plumbing.fnk.schema/split-schema-keys, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 26, :method-params ([G__29237]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :raw-arglists (quote ([s :- {s/Keyword s/Bool}])), :line 102, :end-line 102, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Inputs: [s :- {s/Keyword s/Bool}]\n  Returns: [(s/one [s/Keyword] (quote required)) (s/one [s/Keyword] (quote optional))]\n\n  Given output of explicit-schema-key-map, split into seq [req opt]."}, explicit-schema-key-map {:schema (schema.core/make-fn-schema output-schema29218 [input-schema29219]), :protocol-inline nil, :meta {:arglists (quote ([s])), :file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 93, :column 9, :end-line 93, :end-column 32, :schema (schema.core/make-fn-schema output-schema29218 [input-schema29219]), :doc "Inputs: [s]\n  Returns: {s/Keyword s/Bool}\n\n  Given a possibly-unevaluated map schema, return a map from bare keyword to true\n   (for required) or false (for optional)", :raw-arglists (quote ([s]))}, :name plumbing.fnk.schema/explicit-schema-key-map, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 32, :method-params ([G__29222]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :raw-arglists (quote ([s])), :line 93, :end-line 93, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Inputs: [s]\n  Returns: {s/Keyword s/Bool}\n\n  Given a possibly-unevaluated map schema, return a map from bare keyword to true\n   (for required) or false (for optional)"}, schema-diff {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 166, :column 7, :end-line 166, :end-column 18, :arglists (quote ([input-schema output-schema])), :doc "Subtract output-schema from input-schema, returning nil if it's possible that an object\n   satisfying the output-schema satisfies the input-schema, or otherwise a description\n   of the part(s) of input-schema not met by output-schema.  Strict about the map structure\n   of output-schema matching input-schema, but loose about everything else (only looks at\n   required keys of output-schema."}, :name plumbing.fnk.schema/schema-diff, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 18, :method-params ([input-schema output-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 166, :end-line 166, :max-fixed-arity 2, :fn-var true, :arglists (quote ([input-schema output-schema])), :doc "Subtract output-schema from input-schema, returning nil if it's possible that an object\n   satisfying the output-schema satisfies the input-schema, or otherwise a description\n   of the part(s) of input-schema not met by output-schema.  Strict about the map structure\n   of output-schema matching input-schema, but loose about everything else (only looks at\n   required keys of output-schema."}, non-map-diff {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 68, :column 7, :end-line 68, :end-column 19, :arglists (quote ([s1 s2])), :doc "Return a difference of schmas s1 and s2, where one is not a map.\n   Punt for now, assuming s2 always satisfies s1."}, :name plumbing.fnk.schema/non-map-diff, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 19, :method-params ([s1 s2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 68, :end-line 68, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s1 s2])), :doc "Return a difference of schmas s1 and s2, where one is not a map.\n   Punt for now, assuming s2 always satisfies s1."}, guess-expr-output-schema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 155, :column 7, :end-line 155, :end-column 31, :arglists (quote ([expr])), :doc "Guess an output schema for an expr.  Currently just looks for literal map structure and\n   all keyword keys."}, :name plumbing.fnk.schema/guess-expr-output-schema, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 31, :method-params ([expr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 155, :end-line 155, :max-fixed-arity 1, :fn-var true, :arglists (quote ([expr])), :doc "Guess an output schema for an expr.  Currently just looks for literal map structure and\n   all keyword keys."}, compose-schemata {:schema (schema.core/make-fn-schema output-schema29330 [input-schema29331]), :protocol-inline nil, :meta {:schema (schema.core/make-fn-schema output-schema29330 [input-schema29331]), :file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :end-column 43, :column 27, :raw-arglists (quote ([[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]])), :line 198, :end-line 198, :arglists (quote ([[i2 o2] [i1 o1]])), :doc "Inputs: [[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]]\n\n  Given pairs of input and output schemata for fnks f1 and f2,\n   return a pair of input and output schemata for #(f2 (merge % (f1 %))).\n   f1's output schema must not contain any optional keys.", :always-validate true}, :name plumbing.fnk.schema/compose-schemata, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 43, :method-params ([G__29334 G__29335]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :raw-arglists (quote ([[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]])), :line 198, :end-line 198, :max-fixed-arity 2, :fn-var true, :arglists (quote ([[i2 o2] [i1 o1]])), :doc "Inputs: [[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]]\n\n  Given pairs of input and output schemata for fnks f1 and f2,\n   return a pair of input and output schemata for #(f2 (merge % (f1 %))).\n   f1's output schema must not contain any optional keys.", :always-validate true}, assert-satisfies-schema {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 194, :column 7, :end-line 194, :end-column 30, :arglists (quote ([input-schema output-schema]))}, :name plumbing.fnk.schema/assert-satisfies-schema, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 30, :method-params ([input-schema output-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 194, :end-line 194, :max-fixed-arity 2, :fn-var true, :arglists (quote ([input-schema output-schema]))}, split-schema {:schema (schema.core/make-fn-schema output-schema29362 [input-schema29363]), :protocol-inline nil, :meta {:arglists (quote ([s ks])), :file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 220, :column 9, :end-line 220, :end-column 21, :schema (schema.core/make-fn-schema output-schema29362 [input-schema29363]), :doc "Inputs: [s :- InputSchema ks :- [s/Keyword]]\n\n  Return a pair [ks-part non-ks-part], with any extra schema removed.", :raw-arglists (quote ([s :- InputSchema ks :- [s/Keyword]]))}, :name plumbing.fnk.schema/split-schema, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 21, :method-params ([G__29366 G__29367]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :raw-arglists (quote ([s :- InputSchema ks :- [s/Keyword]])), :line 220, :end-line 220, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s ks])), :doc "Inputs: [s :- InputSchema ks :- [s/Keyword]]\n\n  Return a pair [ks-part non-ks-part], with any extra schema removed."}, assert-distinct {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 39, :column 7, :end-line 39, :end-column 22, :arglists (quote ([things])), :doc "Like (assert (distinct? things)) but with a more helpful error message."}, :name plumbing.fnk.schema/assert-distinct, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 22, :method-params ([things]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 39, :end-line 39, :max-fixed-arity 1, :fn-var true, :arglists (quote ([things])), :doc "Like (assert (distinct? things)) but with a more helpful error message."}, OutputSchema {:name plumbing.fnk.schema/OutputSchema, :file "out/plumbing/fnk/schema.cljs", :line 24, :column 1, :end-line 24, :end-column 18, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 24, :column 6, :end-line 24, :end-column 18}}, GraphInputSchema {:name plumbing.fnk.schema/GraphInputSchema, :file "out/plumbing/fnk/schema.cljs", :line 27, :column 1, :end-line 27, :end-column 22, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 27, :column 6, :end-line 27, :end-column 22}}, GraphIOSchemata {:name plumbing.fnk.schema/GraphIOSchemata, :file "out/plumbing/fnk/schema.cljs", :line 29, :column 1, :end-line 29, :end-column 21, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 29, :column 6, :end-line 29, :end-column 21}}, merge-on-with {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 109, :column 8, :end-line 109, :end-column 21, :private true, :arglists (quote ([key-project key-combine val-combine & maps])), :doc "Like merge-with, but also projects keys to a smaller space and merges them similar to the\n   values.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(key-project key-combine val-combine maps)], :arglists ([key-project key-combine val-combine & maps]), :arglists-meta (nil)}}, :private true, :name plumbing.fnk.schema/merge-on-with, :variadic true, :file "out/plumbing/fnk/schema.cljs", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(key-project key-combine val-combine maps)], :arglists ([key-project key-combine val-combine & maps]), :arglists-meta (nil)}, :method-params [(key-project key-combine val-combine maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 109, :end-line 109, :max-fixed-arity 3, :fn-var true, :arglists ([key-project key-combine val-combine & maps]), :doc "Like merge-with, but also projects keys to a smaller space and merges them similar to the\n   values."}, Schema {:name plumbing.fnk.schema/Schema, :file "out/plumbing/fnk/schema.cljs", :line 22, :column 1, :end-line 22, :end-column 12, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 22, :column 6, :end-line 22, :end-column 12}}, IOSchemata {:name plumbing.fnk.schema/IOSchemata, :file "out/plumbing/fnk/schema.cljs", :line 25, :column 1, :end-line 25, :end-column 16, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 25, :column 6, :end-line 25, :end-column 16}}, union-input-schemata {:schema (schema.core/make-fn-schema output-schema29259 [input-schema29260]), :protocol-inline nil, :meta {:arglists (quote ([i1 i2])), :file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 124, :column 9, :end-line 124, :end-column 29, :schema (schema.core/make-fn-schema output-schema29259 [input-schema29260]), :doc "Inputs: [i1 :- InputSchema i2 :- InputSchema]\n  Returns: InputSchema\n\n  Returns a minimal input schema schema that entails satisfaction of both s1 and s2", :raw-arglists (quote ([i1 :- InputSchema i2 :- InputSchema]))}, :name plumbing.fnk.schema/union-input-schemata, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 29, :method-params ([G__29263 G__29264]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :raw-arglists (quote ([i1 :- InputSchema i2 :- InputSchema])), :line 124, :end-line 124, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i1 i2])), :doc "Inputs: [i1 :- InputSchema i2 :- InputSchema]\n  Returns: InputSchema\n\n  Returns a minimal input schema schema that entails satisfaction of both s1 and s2"}, sequence-schemata {:schema (schema.core/make-fn-schema output-schema29457 [input-schema29458]), :protocol-inline nil, :meta {:arglists (quote ([[i1 o1] [k [i2 o2]]])), :file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 230, :column 9, :end-line 230, :end-column 26, :schema (schema.core/make-fn-schema output-schema29457 [input-schema29458]), :doc "Inputs: [[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword \"key\") (s/one IOSchemata \"inner-schemas\")]]\n  Returns: GraphIOSchemata\n\n  Given pairs of input and output schemata for fnks f1 and f2, and a keyword k,\n   return a pair of input and output schemata for #(let [v1 (f1 %)] (assoc v1 k (f2 (merge-disjoint % v1))))", :raw-arglists (quote ([[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword "key") (s/one IOSchemata "inner-schemas")]]))}, :name plumbing.fnk.schema/sequence-schemata, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 26, :method-params ([G__29461 G__29462]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :raw-arglists (quote ([[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword "key") (s/one IOSchemata "inner-schemas")]])), :line 230, :end-line 230, :max-fixed-arity 2, :fn-var true, :arglists (quote ([[i1 o1] [k [i2 o2]]])), :doc "Inputs: [[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword \"key\") (s/one IOSchemata \"inner-schemas\")]]\n  Returns: GraphIOSchemata\n\n  Given pairs of input and output schemata for fnks f1 and f2, and a keyword k,\n   return a pair of input and output schemata for #(let [v1 (f1 %)] (assoc v1 k (f2 (merge-disjoint % v1))))"}, safe-get {:protocol-inline nil, :meta {:file "/Users/drakezhard/Development/Projects/tic-tac-toe/out/plumbing/fnk/schema.cljs", :line 48, :column 7, :end-line 48, :end-column 15, :arglists (quote ([m k key-path])), :doc "Like (get m k), but throws if k is not present in m."}, :name plumbing.fnk.schema/safe-get, :variadic false, :file "out/plumbing/fnk/schema.cljs", :end-column 15, :method-params ([m k key-path]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 48, :end-line 48, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k key-path])), :doc "Like (get m k), but throws if k is not present in m."}}, :require-macros {schema-macros schema.macros, schema.macros schema.macros, plumbing.fnk.schema plumbing.fnk.schema, s schema.core, schema.core schema.core}, :cljs.analyzer/constants {:seen #{s/Keyword input schema.core/Any :schema required-toplevel-keys s/pair InputSchema i1 k1 k2 = :schema.core/error :key arg1 required :else missing-required-key :does-not-satisfy-schema unwrap-schema-form-key :value map? :proto-sym split-schema-keys s/one :extra explicit-schema-key-map :type input-schema ks compose-schemata s/Bool s/Schema split-schema output schema.core/optional-key s k :error s/maybe quote arg0 :missing-key GraphIOSchemata :doc :failures optional :proto-pred :map union-input-schemata sequence-schemata i2 :always-validate}, :order [:proto-sym :proto-pred s/Schema input output :error :key :map :missing-key :else k :schema schema.core/Any unwrap-schema-form-key :doc s/maybe s/pair s/Keyword s/Bool :type :value :schema.core/error schema.core/optional-key s explicit-schema-key-map required optional split-schema-keys s/one quote i1 InputSchema i2 union-input-schemata :extra = k1 k2 input-schema required-toplevel-keys map? missing-required-key :failures :does-not-satisfy-schema arg0 arg1 compose-schemata :always-validate ks split-schema sequence-schemata GraphIOSchemata]}, :doc "A very simple type system for a subset of schemas consisting of nested\n   maps with optional or required keyword keys; used by fnk and kin.\n\n   Since schemas are turing-complete and not really designed for type inference,\n   (and for simplicity) we err on the side of completeness (allowing all legal programs)\n   at the cost of soundness.\n\n   These operations also bake in some logic specific to reasoning about Graphs,\n   namely that all input keys to a node must be explicitly mentioned as optional or\n   required, or provided via `instance`, and will thus deliberately drop extra key\n   schemas on inputs as appropriate.  Output schemas may not have optional keys."}